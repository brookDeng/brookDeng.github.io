<!DOCTYPE html>
<html lang="zh-tw,en,default">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="greatBrook">
    
    <title>
        
            论坛项目总结 |
        
        Brook&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":["zh-tw","en","default"],"path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#1F69A1","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"风乍起，合当奋意向人生。"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Brook&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">论坛项目总结</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">greatBrook</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-06-20 20:57:04
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/project/">project</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/spring/">spring</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/spring-boot/">spring-boot</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Maven/">Maven</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>13.8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>54 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>涉及到Spring、SpringMVC、Mybatis的整合，以及SpringBoot去简化Spring的配置开发</p>
<p>主要的技术点：</p>
<p>登录注册功能：使用kaptcha去生成验证码，使用邮件完成注册，Redis优化验证码的保存，解决分布式session问题</p>
<p>使用拦截器拦截用户请求，将用户信息绑定在ThreadLocal上</p>
<p>构建Trie数据结构，实现对发表帖子评论的敏感词过滤</p>
<p>支持对帖子评论，也支持对评论进行回复</p>
<p>利用AOP对service的业务代码实现日志记录</p>
<p>利用Redis的zset并结合Redis实现点赞关注的功能</p>
<p>点赞关注后的系统通知，实时性不需要特别高，使用kafka实现异步的发送系统通知</p>
<p>使用ElasticSearch实现对帖子的搜索功能，以及结果的高亮显示</p>
<p>SpringQuartz实现定时任务，完成热门帖子的分数计算模块</p>
<p>使用本地缓存Quartz缓存热门帖子优化热门帖子页面，提高了QPS（10 - 200） <a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/39627757/115350664-f7181500-a1e7-11eb-90df-d3b38eea2991.png"><img src="https://user-images.githubusercontent.com/39627757/115350664-f7181500-a1e7-11eb-90df-d3b38eea2991.png" alt="image"></a> <a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/39627757/115350723-06975e00-a1e8-11eb-821f-1352b36bef15.png"><img src="https://user-images.githubusercontent.com/39627757/115350723-06975e00-a1e8-11eb-821f-1352b36bef15.png" alt="image"></a> <a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/39627757/115350746-0eef9900-a1e8-11eb-90d8-7e37992131fb.png"><img src="https://user-images.githubusercontent.com/39627757/115350746-0eef9900-a1e8-11eb-90d8-7e37992131fb.png" alt="image"></a> <a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/39627757/115350771-19aa2e00-a1e8-11eb-99df-68c08d23ae56.png"><img src="https://gitee.com/brook2bubble/pic-go/raw/master/img/115350771-19aa2e00-a1e8-11eb-99df-68c08d23ae56.png" alt="image"></a> <a target="_blank" rel="noopener" href="https://user-images.githubusercontent.com/39627757/115350801-2169d280-a1e8-11eb-8dfc-7b1431c8953a.png"><img src="https://gitee.com/brook2bubble/pic-go/raw/master/img/115350801-2169d280-a1e8-11eb-8dfc-7b1431c8953a.png" alt="image"></a></p>
<p>处理服务器请求SpringMVC 处理数据库 MyBatis</p>
<p>SSM框架</p>
<p>构建工具：Apache Maven</p>
<p>集成开发工具：IDEA</p>
<p>数据库：Mysql Redis</p>
<p>应用服务器：Tomcat</p>
<p>版本控制工具：Git</p>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><h2 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h2><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a>用户表 user</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>username</td>
<td>varchar</td>
<td>用户名，创建索引</td>
</tr>
<tr>
<td>password</td>
<td>varchar</td>
<td>用户密码</td>
</tr>
<tr>
<td>salt</td>
<td>varchar</td>
<td>加密盐值</td>
</tr>
<tr>
<td>email</td>
<td>varchar</td>
<td>用户邮箱，创建索引</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td>用户类型：0 普通、1 管理员、2 版主</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>用户状态：0 未激活、1 已激活</td>
</tr>
<tr>
<td>activation_code</td>
<td>varchar</td>
<td>激活码</td>
</tr>
<tr>
<td>header_url</td>
<td>varchar</td>
<td>用户头像地址</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>注册时间</td>
</tr>
</tbody></table>
<h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>评论的用户 id，创建索引</td>
</tr>
<tr>
<td>entity_id</td>
<td>int</td>
<td>评论实体 id，创建索引</td>
</tr>
<tr>
<td>entity_type</td>
<td>int</td>
<td>评论实体类型：1 帖子评论、2 评论回复</td>
</tr>
<tr>
<td>target_id</td>
<td>int</td>
<td>评论目标 id</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>评论内容</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>评论状态：0 有效、1 无效</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>评论发表时间</td>
</tr>
</tbody></table>
<h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>发帖的用户 id，创建索引</td>
</tr>
<tr>
<td>title</td>
<td>varchar</td>
<td>帖子表标题</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>帖子内容</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td>帖子类型：0 普通、1 置顶</td>
</tr>
<tr>
<td>comment_count</td>
<td>int</td>
<td>评论数量</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>帖子状态：0 普通、1 精华、2 拉黑</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>评论发表时间</td>
</tr>
</tbody></table>
<h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>登录用户 id</td>
</tr>
<tr>
<td>ticket</td>
<td>varchar</td>
<td>登录凭证，随机字符串</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>登录状态：0 有效、1 无效</td>
</tr>
<tr>
<td>expired</td>
<td>timestamp</td>
<td>过期时间</td>
</tr>
</tbody></table>
<h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>from_id</td>
<td>int</td>
<td>发消息的 id，创建索引</td>
</tr>
<tr>
<td>to_id</td>
<td>int</td>
<td>收消息的 id，创建索引</td>
</tr>
<tr>
<td>conversation_id</td>
<td>varchar</td>
<td>会话 id，由通信双方 id 拼接，创建索引</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>消息内容</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>消息状态：0 未读、1 已读、2 删除</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>消息发送时间</td>
</tr>
</tbody></table>
<h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>帮助构建项目管理项目中的jar包</p>
<p>Maven仓库：存放构件的位置</p>
<p>   -本地仓库：默认是~/.m2/repository</p>
<p>   -远程仓库：中央仓库，镜像仓库，私服仓库</p>
<p><a class="link" target="_blank" rel="noopener" href="https://maven.apache.org/">https://maven.apache.org/<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Maven-构建-Java-项目"><a href="#Maven-构建-Java-项目" class="headerlink" title="Maven 构建 Java 项目"></a>Maven 构建 Java 项目</h2><p>Maven 使用原型 <strong>archetype</strong> 插件创建项目。要创建一个简单的 Java 应用，我们将使用 <strong>maven-archetype-quickstart</strong> 插件。</p>
<p>在下面的例子中，我们将在 C:\MVN 文件夹下创建一个基于 maven 的 java 应用项目。</p>
<p>命令格式如下：</p>
<pre><code>mvn archetype:generate "-DgroupId=com.companyname.bank" "-DartifactId=consumerBanking" "-DarchetypeArtifactId=maven-archetype-quickstart" "-DinteractiveMode=false"
</code></pre>
<p>参数说明：</p>
<ul>
<li><strong>-DgroupId</strong>: 组织名，公司网址的反写 + 项目名称</li>
<li><strong>-DartifactId</strong>: 项目名-模块名</li>
<li><strong>-DarchetypeArtifactId</strong>: 指定 ArchetypeId，maven-archetype-quickstart，创建一个简单的 Java 应用</li>
<li><strong>-DinteractiveMode</strong>: 是否使用交互模式</li>
</ul>
<p>本地仓库地址：E:\Javastudy\maven-repository\repository</p>
<p>配置文件地址：C:\Program Files\Java\apache-maven-3.8.1\conf\settings.xml</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring框架的核心功能有两个：</p>
<ul>
<li>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</li>
<li>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</li>
</ul>
<p>使用依赖注入，不仅可以为Bean注入普通的属性值，还可以注入其他Bean的引用。依赖注入是一种优秀的解耦方式，其可以让Bean以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p>
<p>Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：<strong>控制反转（Inverse of Control，IoC）</strong>。后来Martine Fowler为这种方式起了另一个名称：<strong>依赖注入（Dependency Injection）</strong>，因此不管是依赖注入，还是控制反转，<strong>其含义完全相同</strong>。当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：</p>
<ol>
<li>原始做法: 调用者<strong>主动</strong>创建被依赖对象，然后再调用被依赖对象的方法。</li>
<li>简单工厂模式: 调用者先找到被依赖对象的工厂，然后<strong>主动</strong>通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。</li>
</ol>
<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC Inversion of Control"></a>IoC Inversion of Control</h2><p>控制反转，面向对象编程。</p>
<p>在Java开发中，<strong>Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong></p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TZHi5ApTE14Fcxh/root/content"></p>
<p>图1-1 传统应用程序示意图</p>
<p>　　当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:</p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TdaS3TyMx33Wm6w/root/content"></p>
<p>图1-2有IoC/DI容器后程序结构示意图</p>
<p>传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p><strong>对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。</strong></p>
<p><strong>Spring所倡导的开发方式</strong>就是如此，<strong>所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p>
<h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h2><p><strong>DI—Dependency Injection，即“依赖注入”</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p><strong>“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”</strong></p>
<p>　　●<strong>谁依赖于谁：</strong>当然是<strong>应用程序依赖于IoC容器</strong>；</p>
<p>　　●<strong>为什么需要依赖：****应用程序需要IoC容器来提供对象需要的外部资源</strong>；</p>
<p>　　●<strong>谁注入谁：</strong>很明显是<strong>IoC容器注入应用程序某个对象，应用程序依赖的对象</strong>；</p>
<p>　　<strong>●注入了什么：</strong>就是<strong>注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong>。</p>
<h2 id="IoC和DI由什么关系呢？"><a href="#IoC和DI由什么关系呢？" class="headerlink" title="IoC和DI由什么关系呢？"></a><strong>IoC和DI</strong>由什么<strong>关系</strong>呢？</h2><p>其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系）。</p>
<h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>实现依赖注入的关键，本质上就是一个工厂。</p>
<h2 id="设值注入"><a href="#设值注入" class="headerlink" title="设值注入"></a>设值注入</h2><p>设值注入是指IoC容器通过成员变量的setter方法来注入被依赖对象。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。</p>
<h2 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h2><p>利用构造器来设置依赖关系的方式，被称为构造注入。通俗来说，就是驱动Spring在底层以反射方式执行带指定参数的构造器，当执行带参数的构造器时，就可利用构造器参数对成员变量执行初始化——这就是构造注入的本质。</p>
<h2 id="两种注入方式的对比"><a href="#两种注入方式的对比" class="headerlink" title="两种注入方式的对比"></a>两种注入方式的对比</h2><p>设值注入有如下优点：</p>
<ul>
<li>与传统的JavaBean的写法更相似，程序开发人员更容易理解、接受。通过setter方法设定依赖关系显得更加直观、自然。</li>
<li>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因而导致性能下降。而使用设值注入，则能避免这些问题。</li>
<li>尤其在某些成员变量可选的情况下，多参数的构造器更加笨重。</li>
</ul>
<p>构造注入优势如下：</p>
<ul>
<li>构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</li>
<li>对于依赖关系无需变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器内设定，无须担心后续的代码对依赖关系产生破坏。</li>
<li>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系，对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则。</li>
</ul>
<p>注意：<br>建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。</p>
<h1 id="Spring容器中的Bean"><a href="#Spring容器中的Bean" class="headerlink" title="Spring容器中的Bean"></a>Spring容器中的Bean</h1><p>对于开发者来说，开发者使用Spring框架主要是做两件事：①开发Bean；②配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成”依赖注入”——这就是所谓IoC的本质。</p>
<h2 id="容器中Bean的作用域"><a href="#容器中Bean的作用域" class="headerlink" title="容器中Bean的作用域"></a>容器中Bean的作用域</h2><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下五种作用域：</p>
<ol>
<li>singleton: 单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例。</li>
<li>prototype: 每次通过容器的getBean()方法获取prototype作用域的Bean时，都将产生一个新的Bean实例。</li>
<li>request: 对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。只有在Web应用中使用Spring时，该作用域才真正有效。</li>
<li>session：该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。</li>
<li>global session: 每个全局的HTTP Session对应一个Bean实例。在典型的情况下，仅在使用portlet context的时候有效，同样只在Web应用中有效。</li>
</ol>
<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。prototype作用域的Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成果，就可以重复使用。因此，应该尽量避免将Bean设置成prototype作用域。</p>
<h2 id="使用自动装配注入合作者Bean"><a href="#使用自动装配注入合作者Bean" class="headerlink" title="使用自动装配注入合作者Bean"></a>使用自动装配注入合作者Bean</h2><p>Spring能自动装配Bean与Bean之间的依赖关系，即无须使用ref显式指定依赖Bean，而是由Spring容器检查XML配置文件内容，根据某种规则，为调用者Bean注入被依赖的Bean。<br>Spring自动装配可通过<code>&lt;beans/&gt;</code>元素的<code>default-autowire</code>属性指定，该属性对配置文件中所有的Bean起作用；也可通过对<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性指定，该属性只对该Bean起作用。</p>
<p><code>autowire</code>和<code>default-autowire</code>可以接受如下值：</p>
<ul>
<li><code>no</code>: 不使用自动装配。Bean依赖必须通过ref元素定义。这是默认配置，在较大的部署环境中不鼓励改变这个配置，显式配置合作者能够得到更清晰的依赖关系。</li>
<li><code>byName</code>: 根据setter方法名进行自动装配。Spring容器查找容器中全部Bean，找出其id与setter方法名去掉set前缀，并小写首字母后同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</li>
<li><code>byType</code>: 根据setter方法的形参类型来自动装配。Spring容器查找容器中的全部Bean，如果正好有一个Bean类型与setter方法的形参类型匹配，就自动注入这个Bean；如果找到多个这样的Bean，就抛出一个异常；如果没有找到这样的Bean，则什么都不会发生，setter方法不会被调用。</li>
<li><code>constructor</code>: 与byType类似，区别是用于自动匹配构造器的参数。如果容器不能恰好找到一个与构造器参数类型匹配的Bean，则会抛出一个异常。</li>
<li><code>autodetect</code>: Spring容器根据Bean内部结构，自行决定使用constructor或byType策略。如果找到一个默认的构造函数，那么就会应用byType策略。</li>
</ul>
<p><strong>当一个Bean既使用自动装配依赖，又使用ref显式指定依赖时，则显式指定的依赖覆盖自动装配依赖；对于大型的应用，不鼓励使用自动装配。虽然使用自动装配可减少配置文件的工作量，但大大将死了依赖关系的清晰性和透明性。依赖关系的装配依赖于源文件的属性名和属性类型，导致Bean与Bean之间的耦合降低到代码层次，不利于高层次解耦。</strong></p>
<pre><code>&lt;!--通过设置可以将Bean排除在自动装配之外--&gt;
&lt;bean id="" autowire-candidate="false"/&gt;

&lt;!--除此之外，还可以在beans元素中指定，支持模式字符串，如下所有以abc结尾的Bean都被排除在自动装配之外--&gt;
&lt;beans default-autowire-candidates="*abc"/&gt;
</code></pre>
<h1 id="创建Bean的3种方式"><a href="#创建Bean的3种方式" class="headerlink" title="创建Bean的3种方式"></a>创建Bean的3种方式</h1><h2 id="使用构造器创建Bean实例"><a href="#使用构造器创建Bean实例" class="headerlink" title="使用构造器创建Bean实例"></a>使用构造器创建Bean实例</h2><p>使用构造器来创建Bean实例是最常见的情况，如果不采用构造注入，Spring底层会调用Bean类的无参数构造器来创建实例，因此要求该Bean类提供无参数的构造器。</p>
<p>采用默认的构造器创建Bean实例，Spring对Bean实例的所有属性执行默认初始化，即所有的基本类型的值初始化为0或false；所有的引用类型的值初始化为null。</p>
<h2 id="使用静态工厂方法创建Bean"><a href="#使用静态工厂方法创建Bean" class="headerlink" title="使用静态工厂方法创建Bean"></a>使用静态工厂方法创建Bean</h2><p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是指定Bean实例的实现类，而是静态工厂类，Spring通过该属性知道由哪个工厂类来创建Bean实例。</p>
<p>除此之外，还需要使用factory-method属性来指定静态工厂方法，Spring将调用静态工厂方法返回一个Bean实例，一旦获得了指定Bean实例，Spring后面的处理步骤与采用普通方法创建Bean实例完全一样。如果静态工厂方法需要参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素指定静态工厂方法的参数。</p>
<h2 id="调用实例工厂方法创建Bean"><a href="#调用实例工厂方法创建Bean" class="headerlink" title="调用实例工厂方法创建Bean"></a>调用实例工厂方法创建Bean</h2><p>实例工厂方法与静态工厂方法只有一个不同：调用静态工厂方法只需使用工厂类即可，而调用实例工厂方法则需要工厂实例。使用实例工厂方法时，配置Bean实例的<code>&lt;bean.../&gt;</code>元素无须class属性，配置实例工厂方法使用<code>factory-bean</code>指定工厂实例。<br>采用实例工厂方法创建Bean的<code>&lt;bean.../&gt;</code>元素时需要指定如下两个属性：</p>
<ul>
<li>factory-bean: 该属性的值为工厂Bean的id。</li>
<li>factory-method: 该属性指定实例工厂的工厂方法。</li>
</ul>
<p>若调用实例工厂方法时需要传入参数，则使用<code>&lt;constructor-arg.../&gt;</code>元素确定参数值。</p>
<h1 id="协调作用域不同步的Bean"><a href="#协调作用域不同步的Bean" class="headerlink" title="协调作用域不同步的Bean"></a>协调作用域不同步的Bean</h1><p>当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象，原因是因为当Spring容器初始化时，容器会预初始化容器中所有的<code>singleton Bean</code>，由于<code>singleton Bean</code>依赖于<code>prototype Bean</code>，因此Spring在初始化<code>singleton Bean</code>之前，会先创建<code>prototypeBean</code>——然后才创建<code>singleton Bean</code>，接下里将<code>prototype Bean</code>注入<code>singleton Bean</code>。<br>解决不同步的方法有两种：</p>
<ul>
<li>放弃依赖注入: singleton作用域的Bean每次需要prototype作用域的Bean时，主动向容器请求新的Bean实例，即可保证每次注入的<code>prototype Bean</code>实例都是最新的实例。</li>
<li>利用方法注入: 方法注入通常使用lookup方法注入，使用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个<code>non-singleton Bean</code>。Spring通过使用JDK动态代理或cglib库修改客户端的二进制码，从而实现上述要求。</li>
</ul>
<p>建议采用第二种方法，使用方法注入。为了使用lookup方法注入，大致需要如下两步：</p>
<ol>
<li>将调用者Bean的实现类定义为抽象类，并定义一个抽象方法来获取被依赖的Bean。</li>
<li>在<code>&lt;bean.../&gt;</code>元素中添加<code>&lt;lookup-method.../&gt;</code>子元素让Spring为调用者Bean的实现类实现指定的抽象方法。</li>
</ol>
<p>*<strong>注意：*</strong></p>
<blockquote>
<p>Spring会采用运行时动态增强的方式来实现<code>&lt;lookup-method.../&gt;</code>元素所指定的抽象方法，如果目标抽象类实现过接口，Spring会采用JDK动态代理来实现该抽象类，并为之实现抽象方法；如果目标抽象类没有实现过接口，Spring会采用cglib实现该抽象类，并为之实现抽象方法。Spring4.0的spring-core-xxx.jar包中已经集成了cglib类库。</p>
</blockquote>
<h1 id="两种后处理器"><a href="#两种后处理器" class="headerlink" title="两种后处理器"></a>两种后处理器</h1><p>Spring提供了两种常用的后处理器：</p>
<ul>
<li>Bean后处理器: 这种后处理器会对容器中Bean进行后处理，对Bean进行额外加强。</li>
<li>容器后处理器: 这种后处理器会对IoC容器进行后处理，用于增强容器功能。</li>
</ul>
<h2 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h2><p>Bean后处理器是一种特殊的Bean，这种特殊的Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等，这种Bean称为Bean后处理器。Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。Bean后处理器必须实现<code>BeanPostProcessor</code>接口，同时必须实现该接口的两个方法。</p>
<ol>
<li><code>Object postProcessBeforeInitialization(Object bean, String name) throws BeansException</code>: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</li>
<li><code>Object postProcessAfterinitialization(Object bean, String name) throws BeansException</code>: 该方法的第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean的配置id</li>
</ol>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作，Bean后处理器两个方法的回调时机如下图：</p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TjcHIDsNajtK1_w/root/content"></p>
<p>注意一点，如果使用<code>BeanFactory</code>作为Spring容器，则必须手动注册Bean后处理器，程序必须获取Bean后处理器实例，然后手动注册。</p>
<pre><code>BeanPostProcessor bp = (BeanPostProcessor)beanFactory.getBean("bp");
beanFactory.addBeanPostProcessor(bp);
Person p = (Person)beanFactory.getBean("person");
</code></pre>
<h2 id="容器后处理器"><a href="#容器后处理器" class="headerlink" title="容器后处理器"></a>容器后处理器</h2><p>Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。容器后处理器必须实现<code>BeanFactoryPostProcessor</code>接口，并实现该接口的一个方法<code>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</code>实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>类似于<code>BeanPostProcessor</code>，<code>ApplicationContext</code>可自动检测到容器中的容器后处理器，并且自动注册容器后处理器。但若使用<code>BeanFactory</code>作为Spring容器，则必须手动调用该容器后处理器来处理<code>BeanFactory</code>容器。</p>
<h1 id="SpringBoot配置文件-amp-运行原理"><a href="#SpringBoot配置文件-amp-运行原理" class="headerlink" title="SpringBoot配置文件&amp;运行原理"></a>SpringBoot配置文件&amp;运行原理</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a><strong>1. 前言</strong></h2><p>SpringBoot最核心的就是自动配置类，而自动配置类需要读取配置文件的信息，来自动创建实例，因此配置文件就显得非常重要了。本文主要介绍SpringBoot的配置文件、以及自动配置类和配置文件之间的关系，即SpringBoot的运行原理。</p>
<h2 id="2-SpringBoot-配置文件"><a href="#2-SpringBoot-配置文件" class="headerlink" title="2. SpringBoot 配置文件"></a><strong>2. SpringBoot 配置文件</strong></h2><p>SpringBoot<strong>默认加载</strong>的配置文件是在classpath根目录的<strong>application.properties</strong>或者</p>
<p><strong>application.yml</strong>配置文件。</p>
<p><strong>–注意：</strong></p>
<blockquote>
<p>[1] 文件名不能写错，因为默认的文件名写死在SpringBoot配置代码中。<br>[2] SpringBoot支持properties和yml两个格式的配置文件。</p>
</blockquote>
<h2 id="2-1-配置-Web-服务器"><a href="#2-1-配置-Web-服务器" class="headerlink" title="2.1. 配置 Web 服务器"></a><strong>2.1. 配置 Web 服务器</strong></h2><p>–问题1：为什么SpringBoot明明是一个jar项目而且没有选择服务器组件，但是仍然可以启动项目？</p>
<blockquote>
<p>因为SpringBoot默认内嵌了一个Web服务器（Tomcat）</p>
</blockquote>
<p>–问题2：那么我们如何修改内嵌的Web服务器的参数呢？</p>
<blockquote>
<p>既然已经内嵌在程序里面了，我们也知道SpringBoot的参数就是配置在SpringBoot配置文件里面的。那么当然就是在 SpringBoot配置文件里面配置。</p>
</blockquote>
<h3 id="2-1-1-properties-格式配置"><a href="#2-1-1-properties-格式配置" class="headerlink" title="2.1.1. properties 格式配置"></a><strong>2.1.1. properties 格式配置</strong></h3><p><strong>–Properties 文件的属性，使用的平铺方式书写</strong></p>
<pre><code class="text">## 设置server参数
## 端口
server.port=8080
## 设置下上文路径
server.servlet.context-path=/community
</code></pre>
<h3 id="2-1-2-yml-格式配置"><a href="#2-1-2-yml-格式配置" class="headerlink" title="2.1.2. yml 格式配置"></a><strong>2.1.2. yml 格式配置</strong></h3><p><strong>–Yml 文件的属性使用折叠的方式书写</strong></p>
<pre><code class="text">## 设置server参数
## 注意事项：
## [1] 冒号和参数值之间必须要隔一个空格，否则报错
## [2] 属性设置是有层级之分的
server:
  port: 8080
  servlet:
    context-path: /community
</code></pre>
<h2 id="2-2-多配置文件"><a href="#2-2-多配置文件" class="headerlink" title="2.2. 多配置文件"></a><strong>2.2. 多配置文件</strong></h2><p>需求：希望可以配置多个配置文件，分类存放配置信息。</p>
<h3 id="2-2-1-Properties-配置步骤"><a href="#2-2-1-Properties-配置步骤" class="headerlink" title="2.2.1. Properties 配置步骤"></a><strong>2.2.1. Properties 配置步骤</strong></h3><h3 id="第一步：编写三个配置文件"><a href="#第一步：编写三个配置文件" class="headerlink" title="第一步：编写三个配置文件"></a><strong>第一步：编写三个配置文件</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-adee1ecaccfbe79d0f9eb259023d5237_720w.jpg" alt="img"></p>
<h3 id="第二步：编写配置文件内容"><a href="#第二步：编写配置文件内容" class="headerlink" title="第二步：编写配置文件内容"></a><strong>第二步：编写配置文件内容</strong></h3><p><strong>–注意：</strong></p>
<blockquote>
<p>[1] SpringBoot启动的时候加载的是 application.properties配置文件，再通过application.properties配置文件的<strong>spring.profiles.active属性</strong>指定加载的其他配置文件。<br>[2] 其他配置文件的文件名格式为：<strong>application-XXX.properties。</strong></p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-68966117de00d740cadefb0031bccbf8_720w.jpg" alt="img"></p>
<p><strong>–application.properties</strong></p>
<pre><code class="text">## 指定加载其他配置文件
spring.profiles.active=server1,server2
</code></pre>
<p><strong>–application-server1.properties</strong></p>
<pre><code class="text">## 端口
server.port=8083
</code></pre>
<p><strong>–application-server2.properties</strong></p>
<pre><code class="text">## 设置下上文路径
server.servlet.context-path=/springboot-quickStart-properties
</code></pre>
<h3 id="第三步：运行项目"><a href="#第三步：运行项目" class="headerlink" title="第三步：运行项目"></a><strong>第三步：运行项目</strong></h3><p><strong>–成功结果</strong></p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TH7kmeZMw-HMKJ3/root/content"></p>
<h3 id="2-2-2-Yml-配置步骤"><a href="#2-2-2-Yml-配置步骤" class="headerlink" title="2.2.2. Yml 配置步骤"></a><strong>2.2.2. Yml 配置步骤</strong></h3><h3 id="第一步：编写三个-yml-配置文件"><a href="#第一步：编写三个-yml-配置文件" class="headerlink" title="第一步：编写三个 yml 配置文件"></a><strong>第一步：编写三个 yml 配置文件</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-a1d4921cb76e1fa9d5abc9d664382b11_720w.jpg" alt="img"></p>
<h3 id="第二步：分别编写配置信息"><a href="#第二步：分别编写配置信息" class="headerlink" title="第二步：分别编写配置信息"></a><strong>第二步：分别编写配置信息</strong></h3><p><strong>–注意：</strong></p>
<blockquote>
<p>[1] SpringBoot启动的时候加载的是 application.yml 配置文件，再通过application.yml配置文件的<strong>spring.profiles.active属性</strong>指定加载的其他配置文件。<br>[2] 其他配置文件的文件名格式为：<strong>application-.yml。</strong></p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-fd0296faf2d4504d7d407e539584f305_720w.jpg" alt="img"></p>
<p><strong>–application.yml</strong></p>
<pre><code class="text">## 指定加载其他配置文件
spring:
  profiles:
    active: server1,server2
</code></pre>
<p><strong>–application-server1.yml</strong></p>
<pre><code class="text">## 端口
server:
  port: 8084
</code></pre>
<p><strong>–application-server2.yml</strong></p>
<pre><code class="text">## 设置下上文路径
server:
  servlet:
    context-path: /springboot-quickStart-yml
</code></pre>
<h3 id="第三步：启动测试"><a href="#第三步：启动测试" class="headerlink" title="第三步：启动测试"></a><strong>第三步：启动测试</strong></h3><p><strong>–成功结果</strong></p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TouymBo9qdwo6PW/root/content"></p>
<h2 id="3-SpringBoot-运行原理"><a href="#3-SpringBoot-运行原理" class="headerlink" title="3. SpringBoot 运行原理"></a><strong>3. SpringBoot 运行原理</strong></h2><blockquote>
<p>通过理解<strong>SpringBoot运行流程图</strong>，来理解功能组件的属性是放在哪里的，通过边学边找的方式来记忆规律。</p>
</blockquote>
<p><strong>–如图所示：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-945cd56e31bd68dc2db05472ed7f692c_720w.jpg" alt="img"></p>
<p><strong>启动流程：</strong></p>
<blockquote>
<p>第一步：SpringBoot通过加载贴在入口执行类上面的@SpringBootApplication注解，来启动 SpringBoot 项目。<br>第二步：根据贴在@SpringBootApplication注解上的三个注@SpringBootConfiguraton、 @EnableAutoConfiguration、@ComponentScan，来加载SpringBoot配置类、自动加载的配置类、组件类。</p>
</blockquote>
<p><strong>3个注解的功能如下：</strong></p>
<blockquote>
<p><strong>@SpringBootConfiguraton：</strong>标识一个类是配置类。<br><strong>@EnableAutoConfiguration：</strong>标识这是一个自动加载的配置类，在SpringBoot启动的时候就自动加载配置类中的组件到容器中。<br><strong>@ComponentScan：</strong>标识需要组件扫描的包，在SpringBoot中，包扫描给入口类所在包及其入口类的子包。</p>
</blockquote>
<p><em><strong>*注意事项：</strong>SpringBoot内置支持的组件在</em><em>spring-boot-autoconfigure-2.2.2.RELEASE.jar</em>* 里面。如该<strong>包下的jdbc分包下的DataSourceAutoConfiguration：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-424af7413e15f2657999b7ccde2a2996_720w.png" alt="img"></p>
<p><strong>其中的EnableConfigurationProperties注解用于加载用户配置的参数信息。</strong></p>
<p><strong>DataSourceProperties的作用就是标识配置文件中那些信息是DataSource使用的，标识的方式就是使用“spring.datasource”前缀。</strong></p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TkABG0mIjpwsukG/root/content"></p>
<p><strong>–根据分析，可以得出结论：</strong>自动加载的配置类信息都在 Xxx<strong>AutoConfiguration</strong>里面，配</p>
<p>置的属性参数都在Xxxxx<strong>Properties</strong>里面。</p>
<p><strong>–执行原理图</strong>：</p>
<p><img src="https://pic4.zhimg.com/80/v2-98fdaa5758d40191cf671ac792d39593_720w.jpg" alt="img"></p>
<p><strong>总结：通过执行原理图，可以知道SpringBoot是如何实现自动配置的。</strong></p>
<h1 id="Spring的”零配置”支持"><a href="#Spring的”零配置”支持" class="headerlink" title="Spring的”零配置”支持"></a>Spring的”零配置”支持</h1><h2 id="搜索Bean类"><a href="#搜索Bean类" class="headerlink" title="搜索Bean类"></a>搜索Bean类</h2><p>Spring提供如下几个Annotation来标注Spring Bean：</p>
<ul>
<li><code>@Component</code>: 标注一个普通的Spring Bean类</li>
<li><code>@Controller</code>: 标注一个控制器组件类</li>
<li><code>@Service</code>: 标注一个业务逻辑组件类</li>
<li><code>@Repository</code>: 标注一个DAO组件类</li>
</ul>
<p>在Spring配置文件中做如下配置，指定自动扫描的包：</p>
<pre><code>&lt;context:component-scan base-package="edu.shu.spring.domain"/&gt;
</code></pre>
<h2 id="使用-Resource配置依赖"><a href="#使用-Resource配置依赖" class="headerlink" title="使用@Resource配置依赖"></a>使用@Resource配置依赖</h2><p><code>@Resource</code>位于<code>javax.annotation</code>包下，是来自JavaEE规范的一个<code>Annotation</code>，Spring直接借鉴了该<code>Annotation</code>，通过使用该<code>Annotation</code>为目标Bean指定协作者Bean。使用<code>@Resource</code>与<code>&lt;property.../&gt;</code>元素的ref属性有相同的效果。<br><code>@Resource</code>不仅可以修饰setter方法，也可以直接修饰实例变量，如果使用<code>@Resource</code>修饰实例变量将会更加简单，此时Spring将会直接使用JavaEE规范的Field注入，此时连setter方法都可以不要。</p>
<h2 id="使用-PostConstruct和-PreDestroy定制生命周期行为"><a href="#使用-PostConstruct和-PreDestroy定制生命周期行为" class="headerlink" title="使用@PostConstruct和@PreDestroy定制生命周期行为"></a>使用@PostConstruct和@PreDestroy定制生命周期行为</h2><p><code>@PostConstruct</code>和<code>@PreDestroy</code>同样位于javax.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。它们都用于修饰方法，无须任何属性。其中前者修饰的方法时Bean的初始化方法；而后者修饰的方法时Bean销毁之前的方法。</p>
<h2 id="Spring4-0增强的自动装配和精确装配"><a href="#Spring4-0增强的自动装配和精确装配" class="headerlink" title="Spring4.0增强的自动装配和精确装配"></a>Spring4.0增强的自动装配和精确装配</h2><p>Spring提供了<code>@Autowired</code>注解来指定自动装配，<code>@Autowired</code>可以修饰setter方法、普通方法、实例变量和构造器等。当使用<code>@Autowired</code>标注setter方法时，默认采用byType自动装配策略。在这种策略下，符合自动装配类型的候选Bean实例常常有多个，这个时候就可能引起异常，为了实现精确的自动装配，Spring提供了<code>@Qualifier</code>注解，通过使用<code>@Qualifier</code>，允许根据Bean的id来执行自动装配。</p>
<h1 id="异步请求ajax"><a href="#异步请求ajax" class="headerlink" title="异步请求ajax"></a>异步请求ajax</h1><p> * asynchronous javascript and xml：异步的js和xml</p>
<p> * 它能使用js访问服务器，而且是异步访问</p>
<p> * 服务器给客户端的响应一般是整个页面，一个html完整页面！但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面！而只是数据</p>
<p>  &gt; text：纯文本</p>
<p>  &gt; xml：大家都熟悉</p>
<p>  &gt; json：它是js提供的数据交互格式，它在ajax中最受欢迎</p>
<h2 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h2><h3 id="1-创建Ajax对象（得到XMLHttpRequest）"><a href="#1-创建Ajax对象（得到XMLHttpRequest）" class="headerlink" title="1.创建Ajax对象（得到XMLHttpRequest）"></a>1.创建Ajax对象（得到XMLHttpRequest）</h3><p>* ajax其实只需要学习一个对象：XMLHttpRequest，如果掌握了它，就掌握了ajax！</p>
<pre><code>var request=new XMLHttpRequest();

注意：如果要兼容IE6以下浏览器则需要编写如下代码

var request;

if(window.XMLRequest){
request=new XMLRequestHttpRequest();  //IE7、IE8、360等

}else{
request=new ActiveXObject("Microsoft.XMLHTTP");//IE5、IE6

}
</code></pre>
<h3 id="2-链接到服务器（打开与服务器的连接）"><a href="#2-链接到服务器（打开与服务器的连接）" class="headerlink" title="2.链接到服务器（打开与服务器的连接）"></a>2.链接到服务器（打开与服务器的连接）</h3><h3 id="3-发送请求（发送请求）"><a href="#3-发送请求（发送请求）" class="headerlink" title="3.发送请求（发送请求）"></a>3.发送请求（发送请求）</h3><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法。</p>
<p>语法：open(method,url,async)和xmlhttp.send()。</p>
<h3 id="4-接受返回值"><a href="#4-接受返回值" class="headerlink" title="4.接受返回值"></a>4.接受返回值</h3><p>* xmlHttp对象一共有5个状态：</p>
<p>  &gt; 0状态：刚创建，还没有调用open()方法; </p>
<p>  &gt; 1状态：请求开始：调用了open()方法，但还没有调用send()方法</p>
<p>  &gt; 2状态：调用完了send()方法了；</p>
<p>  &gt; 3状态：服务器已经开始响应，但不表示响应结束了！</p>
<p>  &gt; 4状态：服务器响应结束！（通常我们只关心这个状态！！！）</p>
<h1 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h1><h2 id="为什么需要AOP"><a href="#为什么需要AOP" class="headerlink" title="为什么需要AOP"></a>为什么需要AOP</h2><p>AOP（Aspect Orient Programming）也就是面向切面编程，作为面向对象编程的一种补充，已经成为一种比较成熟的编程方式,面向切面编程将程序运行过程分解成各个切面。</p>
<p>AOP专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<h2 id="使用AspectJ实现AOP"><a href="#使用AspectJ实现AOP" class="headerlink" title="使用AspectJ实现AOP"></a>使用AspectJ实现AOP</h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。其主要包括两个部分：一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，可以方便地用AOP来解决Java语言中存在的交叉关注点的问题；另一个部分是工具部分，包括编译、调试工具等。</p>
<p>AOP实现可分为两类：</p>
<ol>
<li>静态AOP实现: AOP框架在编译阶段对程序进行修改，即实现对目标类的增强，生成静态的AOP代理类，以AspectJ为代表。</li>
<li>动态AOP实现: AOP框架在运行阶段动态生成AOP代理，以实现对目标对象的增强，以Spring AOP为代表。</li>
</ol>
<p>一般来说，静态AOP实现具有较好的性能，但需要使用特殊的编译器。动态AOP实现是纯Java实现，因此无须特殊的编译器，但是通常性能略差。</p>
<h2 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h2><p>关于面向切面编程的一些术语：</p>
<ul>
<li>切面（Aspect）: 切面用于组织多个Advice，Advice放在切面中定义。</li>
<li>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。</li>
<li>增强处理（Advice）: AOP框架在特定的切入点执行的增强处理。处理有”around”、”before”和”after”等类型</li>
<li>切入点（Pointcut）: 可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。</li>
</ul>
<h2 id="Spring的AOP支持"><a href="#Spring的AOP支持" class="headerlink" title="Spring的AOP支持"></a>Spring的AOP支持</h2><p>Spring中的AOP代理由Spring的IoC容器负责生成、管理，其依赖关系也由IoC容器负责管理。<br>为了在应用中使用<code>@AspectJ</code>支持，Spring需要添加三个库：</p>
<ul>
<li><code>aspectjweaver.jar</code></li>
<li><code>aspectjrt.jar</code></li>
<li><code>aopalliance.jar</code></li>
</ul>
<p>并在Spring配置文件中做如下配置：</p>
<pre><code>&lt;!--启动@AspectJ支持--&gt;
&lt;aop:aspectj-autoproxy/&gt;

&lt;!--指定自动搜索Bean组件、自动搜索切面类--&gt;
&lt;context:component-scan base-package="edu.shu.sprint.service"&gt;
    &lt;context:include-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<h1 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h1><p>@Repository和@Controller、@Service、@Component的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理。</p>
<h2 id="Spring的核心机制"><a href="#Spring的核心机制" class="headerlink" title="Spring的核心机制"></a>Spring的核心机制</h2><h3 id="管理Bean"><a href="#管理Bean" class="headerlink" title="管理Bean"></a>管理Bean</h3><p>程序主要是通过Spring容器来访问容器中的Bean，ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类：</p>
<ul>
<li>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</li>
<li>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</li>
</ul>
<pre><code>public class BeanTest{
    public static void main(String args[]) throws Exception{
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Person p = ctx.getBean("person", Person.class);
        p.say();
    }
</code></pre>
<h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><p>​    面向切面编程思想，是对OOP的补充 进一步提高编程效率。web层级设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面。编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="Aspect（切面）："><a href="#Aspect（切面）：" class="headerlink" title="Aspect（切面）："></a>Aspect（切面）：</h4><p> Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</p>
<h4 id="Joint-point（连接点）："><a href="#Joint-point（连接点）：" class="headerlink" title="Joint point（连接点）："></a>Joint point（连接点）：</h4><p>表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</p>
<h4 id="Pointcut（切点）："><a href="#Pointcut（切点）：" class="headerlink" title="Pointcut（切点）："></a>Pointcut（切点）：</h4><p>表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</p>
<h4 id="Advice（增强）："><a href="#Advice（增强）：" class="headerlink" title="Advice（增强）："></a>Advice（增强）：</h4><p>Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</p>
<h4 id="Target（目标对象）："><a href="#Target（目标对象）：" class="headerlink" title="Target（目标对象）："></a>Target（目标对象）：</h4><p>织入 Advice 的目标对象.。</p>
<h4 id="Weaving（织入）："><a href="#Weaving（织入）：" class="headerlink" title="Weaving（织入）："></a>Weaving（织入）：</h4><p>将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</p>
<h3 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h3><h4 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h4><p>​            AspectJ是语言级的实现，它扩展了Java语言，定义了AOP语法<br>​            AspectJ在编译期织入代码，他有一个专门的编译器，用来生成遵守Java字节码规范的class文件，基于字节码操作</p>
<h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>​            Spring AOP 使用纯Java实现，不需要专门的编译过程，也不需要特殊的类装载器。<br>​            Spring AOP在运行时通过代理的方式织入代码，只支持方法类型的连接点<br>​            Spring支持对AspectJ的集成</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://gitee.com/brook2bubble/pic-go/raw/master/img/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>​                    Java提供的动态代理技术 可以在运行时创建接口的代理事例<br>​                    Spring　AOP 默认采用此种技术 在接口的代理实例中织入代码</p>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>​                    采用底层的字节码技术 在运行时创建子类代理实例<br>​                    当目标对象不存在接口时 SpringAOP会采用此种方式 在子类实例中织入代码</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p>
<p>1.字符串（strings）<br>2.字符串列表（lists）<br>3.字符串集合（sets）<br>4.有序字符串集合（sorted sets）<br>5.哈希（hashes）</p>
<p>而关于key，有几个点要提醒大家：</p>
<p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p>
<h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h2 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h2><p>缓存，排行榜，计数器，社交网络，消息队列等</p>
<h2 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h2><p><a class="link" target="_blank" rel="noopener" href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases<i class="fas fa-external-link-alt"></i></a></p>
<p>安装后最好配置一下系统环境变量</p>
<h3 id="使用-cmd"><a href="#使用-cmd" class="headerlink" title="使用 cmd"></a>使用 cmd</h3><pre><code class="shell">C:\Users\dgx19&gt;redis-cli  //启动
127.0.0.1:6379&gt; select 1 //选择数据库
OK
127.0.0.1:6379[1]&gt; select 0 //选择默认数据库
OK
127.0.0.1:6379&gt; flushdb  //清除缓冲区
OK

1.字符串（strings）
2.字符串列表（lists）
3.字符串集合（sets）
4.有序字符串集合（sorted sets）
5.哈希（hashes）

//Strings类型 

127.0.0.1:6379&gt; set test:count 1  //设置String键值
OK
127.0.0.1:6379&gt; get test:count  //获取键值
"1"
127.0.0.1:6379&gt; incr test:count  //值加1
(integer) 2
127.0.0.1:6379&gt; decr test:count  //值减1
(integer) 0

//hashes类型

127.0.0.1:6379&gt; hset test:user id 1 //设置Hash键值
(integer) 1
127.0.0.1:6379&gt; hset test:user username zhangsan
(integer) 1
127.0.0.1:6379&gt; hget test:user id  //获取hash键值
"1"
127.0.0.1:6379&gt; hget test:user username
"zhangsan"

//Lists类型

127.0.0.1:6379&gt; lpush test:ids 101 102 103 104 //左进
(integer) 4
127.0.0.1:6379&gt; llen test:ids  //list长度查询
(integer) 4
127.0.0.1:6379&gt; lindex test:ids 0  //左部索引
"104"
127.0.0.1:6379&gt; lrange test:ids 0 2 //区域元素索引
1) "104"
2) "103"
3) "102"
127.0.0.1:6379&gt; rpop test:ids  //右出为先进先出队列 左出为先进后出栈
"101"
127.0.0.1:6379&gt; rpop test:ids 
"102"

//集合sets

127.0.0.1:6379&gt; sadd test:teachers aaa bbb vvv ccc //集合添加元素
(integer) 4
127.0.0.1:6379&gt; scard test:teachers  //统计元素数量
(integer) 4
127.0.0.1:6379&gt; spop test:teachers  //随即弹出一个元素
"vvv"
127.0.0.1:6379&gt; spop test:teachers
"bbb"
127.0.0.1:6379&gt; smembers test:teachers  //显示当前集合所有元素
1) "aaa"
2) "ccc"

//sorted sets 有序集合 按照score排序

127.0.0.1:6379&gt;zadd test:students 01 aaa 02 bbb 03 ccc
127.0.0.1:6379&gt;zcard test:students
127.0.0.1:6379&gt;zscore test:students aaa
127.0.0.1:6379&gt;zrank test:students aaa 
127.0.0.1:6379&gt;zrange test:students 0 3

//全局命令

keys * 查询当前库里共有多少key
key test* 查询当前库里test开头的key
type test:user  查询test：user是什么类型的key
exists test:user 查询是否存在此key
del test:user  删除key
expire test:students n 设置key存在时间 n秒
</code></pre>
<h2 id="Spring整合Redis"><a href="#Spring整合Redis" class="headerlink" title="Spring整合Redis"></a>Spring整合Redis</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>spring-boot-starter-data-redis</p>
<h3 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h3><p>配置数据库参数</p>
<p>编写配置类，构造RedisTemplate</p>
<h3 id="访问Redis"><a href="#访问Redis" class="headerlink" title="访问Redis"></a>访问Redis</h3><p>redisTemplate.opsForValue()</p>
<p>redisTemplate.opsForHash()</p>
<p>redisTemplate.opsForList()</p>
<p>redisTemplate.opsForSet()</p>
<p>redisTemplate.opsForZSet()</p>
<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><pre><code>// 编程式事务
    @Test
    public void testTransaction() {
        Object result = redisTemplate.execute(new SessionCallback() {
            @Override
            public Object execute(RedisOperations redisOperations) throws DataAccessException {
                String redisKey = "text:tx";
                // 启用事务
                redisOperations.multi();               redisOperations.opsForSet().add(redisKey, "zhangsan");              redisOperations.opsForSet().add(redisKey, "lisi");             redisOperations.opsForSet().add(redisKey, "wangwu");               System.out.println(redisOperations.opsForSet().members(redisKey));
                // 提交事务
                return redisOperations.exec();
            }
        });
        System.out.println(result);
    }
</code></pre>
<h2 id="Redis高级数据类型"><a href="#Redis高级数据类型" class="headerlink" title="Redis高级数据类型"></a>Redis高级数据类型</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>采用一种基数算法，用于完成独立总数的统计<br>占据空间小，无论统计多少个数据，只占12k的内存<br>不精确的统计算法，标准误差为0.81%</p>
<h3 id="Bitmap（统计用户的签到情况）"><a href="#Bitmap（统计用户的签到情况）" class="headerlink" title="Bitmap（统计用户的签到情况）"></a>Bitmap（统计用户的签到情况）</h3><p>不是一种独立的数据结构，实际上就是字符串<br>支持按位存取数据，可以将其看成是byte数组<br>适合存储大量的联系的数据的布尔值\</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="UV（Unique-Visitor）"><a href="#UV（Unique-Visitor）" class="headerlink" title="UV（Unique Visitor）"></a>UV（Unique Visitor）</h3><p>独立访客，需通过用户ip排重统计数据。<br>每次访问都要进行统计<br>HyperLogLog，性能好且存储空间小</p>
<h3 id="DAU（Daily-Active-User）"><a href="#DAU（Daily-Active-User）" class="headerlink" title="DAU（Daily Active User）"></a>DAU（Daily Active User）</h3><p>日活跃用户，需通过用户ID排重统计数据<br>访问过一次，则认为其活跃<br>BitMap，性能好且可以统计精确的结果</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="消息系统介绍"><a href="#消息系统介绍" class="headerlink" title="消息系统介绍"></a>消息系统介绍</h2><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：<strong>点对点传递模式、发布-订阅模式</strong>。大部分的消息系统选用发布-订阅模式。<strong>Kafka就是一种发布-订阅模式</strong>。</p>
<h3 id="点对点消息传递模式"><a href="#点对点消息传递模式" class="headerlink" title="点对点消息传递模式"></a>点对点消息传递模式</h3><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：</p>
<p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29TsMrFYg0AgY0k9-/root/content"></p>
<p><strong>生产者发送一条消息到queue，只有一个消费者能收到</strong>。</p>
<h3 id="发布-订阅消息传递模式"><a href="#发布-订阅消息传递模式" class="headerlink" title="发布-订阅消息传递模式"></a>发布-订阅消息传递模式</h3><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p>
<p><img src="https://gitee.com/brook2bubble/pic-go/raw/master/img/1228818-20180507190443404-1266011458.png" alt="img"></p>
<p><strong>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息</strong>。</p>
<h2 id="Kafka的优点"><a href="#Kafka的优点" class="headerlink" title="Kafka的优点"></a>Kafka的优点</h2><p>解耦  冗余（副本） 扩展性 灵活性&amp;峰值处理能力 可恢复性　顺序保证　缓冲　异步通信</p>
<h2 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在深入理解Kafka之前，先介绍一下Kafka中的术语。下图展示了Kafka的相关术语以及之间的关系：</p>
<p><img src="https://gitee.com/brook2bubble/pic-go/raw/master/img/1228818-20180507190731172-1317551019.png" alt="img"></p>
<p>上图中一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p>
<p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</p>
<p>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<p>类似于数据库的表名</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a><strong>Partition</strong></h3><p>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息<strong>追加</strong>到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
<h3 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h3><p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</p>
<h3 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h3><p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>E:\Javastudy\kafka\kafka_2.13-2.8.0\config</p>
<p>zookeeper.properties  server.properties 更改存储位置</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0&gt;bin\windows\zookeeper-server-start.bat config\zookeeper.properties
</code></pre>
<h3 id="启动kafka-server"><a href="#启动kafka-server" class="headerlink" title="启动kafka server"></a>启动kafka server</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0&gt;bin\windows\kafka-server-start.bat config\server.properties
</code></pre>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0\bin\windows&gt;kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test
Created topic test.
// --replication-factor 1 用来设置主题的副本数。每个主题可以有多个副本，副本位于集群中不同的broker上，也就是说副本的数量不能超过broker的数量，否则创建主题时会失败。
//localhost:9092 服务器地址  
//--partitions 1   　主题分区数
//--topic 主题名称
</code></pre>
<h3 id="查看主题"><a href="#查看主题" class="headerlink" title="查看主题"></a>查看主题</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0\bin\windows&gt;kafka-topics.bat --list --bootstrap-server localhost:9092
test
</code></pre>
<h3 id="创建消息（生产者）"><a href="#创建消息（生产者）" class="headerlink" title="创建消息（生产者）"></a>创建消息（生产者）</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0\bin\windows&gt;kafka-console-producer.bat --broker-list localhost:9092 --topic test
&gt;hello
</code></pre>
<h3 id="查看消息（消费者）"><a href="#查看消息（消费者）" class="headerlink" title="查看消息（消费者）"></a>查看消息（消费者）</h3><pre><code>e:\Javastudy\kafka\kafka_2.13-2.8.0\bin\windows&gt;kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning
hello
</code></pre>
<h1 id="spring整合kafka"><a href="#spring整合kafka" class="headerlink" title="spring整合kafka"></a>spring整合kafka</h1><h2 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
    &lt;version&gt;2.7.5&lt;/version&gt;
&lt;/dependency&gt;
pom.xml
</code></pre>
<h2 id="配置application-properties"><a href="#配置application-properties" class="headerlink" title="配置application.properties"></a>配置application.properties</h2><pre><code>#KafkaProperties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=community-consumer-group 
spring.kafka.consumer.enable-auto-commit=true  //自动提交 
spring.kafka.consumer.auto-commit-interval=3000  //自动提交间隔3s
</code></pre>
<h1 id="系统消息通知"><a href="#系统消息通知" class="headerlink" title="系统消息通知"></a>系统消息通知</h1><p>点赞 评论 回复</p>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>使用kafka消息分发，message表存储消息</p>
<p>主要消息内容content采用json存储</p>
<pre><code>{"entityType":1,"entityId":280,"postId":280,"userId":149}
</code></pre>
<h3 id="实体类Event"><a href="#实体类Event" class="headerlink" title="实体类Event"></a>实体类Event</h3><pre><code>public class Event {
    private String topic;
    private int userId;
    private int entityType;
    private int entityId;
    private int entityUserId;
    private Map&lt;String,Object&gt; data = new HashMap&lt;&gt;();
    public String getTopic() {
        return topic;
    }
    public Event setTopic(String topic) {
        this.topic = topic;
        return this;
    }
    public int getUserId() {
        return userId;
    }
    public Event setUserId(int userId) {
        this.userId = userId;
        return this;
    }
    public int getEntityType() {
        return entityType;
    }
    public Event setEntityType(int entityType) {
        this.entityType = entityType;
        return this;
    }
    public int getEntityId() {
        return entityId;
    }
    public Event setEntityId(int entityId) {
        this.entityId = entityId;
        return this;
    }
    public int getEntityUserId() {
        return entityUserId;
    }
    public Event setEntityUserId(int entityUserId) {
        this.entityUserId = entityUserId;
        return this;
    }
    public Map&lt;String, Object&gt; getData() {
        return data;
    }
    public Event setData(String key, Object value) {
        this.data.put(key,value);
        return this;
    }
}
</code></pre>
<h3 id="设置kafka-eventConsumer-eventProducer"><a href="#设置kafka-eventConsumer-eventProducer" class="headerlink" title="设置kafka eventConsumer eventProducer"></a>设置kafka eventConsumer eventProducer</h3><p>在conroller层触发点赞关注回复事件时调用eventProducer.fireEvent（event）向用户发送消息</p>
<h3 id="用户在消息页面查看所有消息"><a href="#用户在消息页面查看所有消息" class="headerlink" title="用户在消息页面查看所有消息"></a>用户在消息页面查看所有消息</h3><pre><code>查看系统通知详情页 分类显示
但是原项目查看点赞回复时是直接到相应帖子首页
后续想实现直接跳转到具体点赞和回复所在的页面
</code></pre>
<pre><code>1.新加查询 
通过message表中消息create_time
在comment中查询相应的排序数 通过（i-1）/5 +1 为sortNo值
然后通过controller传递给页面，页面因为本身还要传递postId 就需要th：href解析两个变量
之前是
th:href="@{|/discuss/detail/${map.postId}|}"
解析后地址http://localhost:8080/community/discuss/detail/283
实现方式为
th:href="${'/community/discuss/detail/'}+${map.postId}+${'?current='}+${map.sortNo}"
解析后地址http://localhost:8080/community/discuss/detail/283?current=1

但是由于点赞关注采用Redis实现 两个表的相关数据创建时间出现了偏差，导致系统查询排序数返回null 导致500错误，只能从底层改造



</code></pre>
<p>2.在消息content中加入sortNo</p>
<p>CommentController</p>
<pre><code>//触发评论事件
        Event event = new Event()
                .setTopic(TOPIC_COMMENT)
                .setUserId(hostHolder.getUser().getId())
                .setEntityType(comment.getEntityType())
                .setEntityId(comment.getEntityId())
                .setData("postId",discussPostId);

        if (comment.getEntityType()== ENTITY_TYPE_POST){
            DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());
            event.setEntityUserId(target.getUserId())
                    .setData("sortNo",commentService.findIdFromCreateDate(comment.getCreateTime()));
        }
        eventProducer.fireEvent(event);
</code></pre>
<p>MessageController</p>
<pre><code>/**
                 * 如果topic是评论帖子或者回复就返回到该评论所在页数
                 * 如果topic是点赞帖子 返回帖子 点赞对象是评论就返回到评论所在页数
                 */
                if(topic.equals(TOPIC_COMMENT)){
                    int sortNo = 0;
                    if ((Integer)data.get("entityType")==ENTITY_TYPE_POST){
                       sortNo= commentService.findCommentSortById(ENTITY_TYPE_POST, (Integer) data.get("postId"), (Integer) data.get("sortNo"));
                    }else if ((Integer)data.get("entityType")==ENTITY_TYPE_COMMENT){
                        sortNo= commentService.findCommentSortById(ENTITY_TYPE_POST, (Integer) data.get("postId"), (Integer) data.get("entityId"));

                    }
                    sortNo = (sortNo - 1) / 5 + 1;
                        map.put("sortNo",sortNo);
                }
                if(topic.equals(TOPIC_LIKE)){
                    int sortNo = 0;
                    if ((Integer)data.get("entityType")==ENTITY_TYPE_COMMENT){
                        Comment comment = commentService.findCommentById((Integer) data.get("entityId"));
                        if (comment.getEntityType() == ENTITY_TYPE_POST){
                            sortNo= commentService.findCommentSortById(ENTITY_TYPE_POST, (Integer) data.get("postId"), (Integer) data.get("entityId"));
                        }else if (comment.getEntityType() == ENTITY_TYPE_COMMENT){
                            sortNo= commentService.findCommentSortById(ENTITY_TYPE_POST, (Integer) data.get("postId"), comment.getEntityId());
                        }


                        sortNo = (sortNo - 1) / 5 + 1;
                    }

                    map.put("sortNo",sortNo);
                }
</code></pre>
<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><pre><code>https://zhuanlan.zhihu.com/p/358744225
</code></pre>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><pre><code>https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.14.0-windows-x86_64.zip
</code></pre>
<p>直接解压到文件夹Javastudy/elasticSearch</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>config/elasticsearch.yml</p>
<pre><code>cluster.name: brook
node.name: node01
path.data: e:\Javastudy\data\elasticsearch-7.12.1\data
path.logs: e:\Javastudy\data\elasticsearch-7.12.1\logs
cluster.initial_master_nodes: ["node01"]
</code></pre>
<h2 id="添加中文的分词插件"><a href="#添加中文的分词插件" class="headerlink" title="添加中文的分词插件"></a>添加中文的分词插件</h2><p>默认是英文分词</p>
<pre><code>https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.12.1
</code></pre>
<p>解压到</p>
<pre><code>E:\Javastudy\elasticsearch-7.12.1\plugins\ik
</code></pre>
<h2 id="启动与使用"><a href="#启动与使用" class="headerlink" title="启动与使用"></a>启动与使用</h2><p>bin目录 .bat</p>
<p>查看健康状况</p>
<pre><code>curl -X GET "localhost:9200/_cat/health?v"
</code></pre>
<pre><code>查看节点数
C:\Users\dgx19&gt;curl -X GET "localhost:9200/_cat/nodes?v"
ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role   master name
127.0.0.1           28          60  23                          cdfhilmrstw *      BROOK
</code></pre>
<pre><code>创建和查看索引
C:\Users\dgx19&gt;curl -X PUT "localhost:9200/test"
{"acknowledged":true,"shards_acknowledged":true,"index":"test"}
C:\Users\dgx19&gt;curl -X GET "localhost:9200/_cat/indices?v"
health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   test  f1n0-1QkQjOB8aDSiEGFOA   1   1          0            0       208b           208b
</code></pre>
<pre><code>删除索引
C:\Users\dgx19&gt;curl -X DELETE "localhost:9200/test"
{"acknowledged":true}
</code></pre>
<h2 id="Postman安装与使用"><a href="#Postman安装与使用" class="headerlink" title="Postman安装与使用"></a>Postman安装与使用</h2><p>Postman一款非常流行的API调试工具。其实，开发人员用的更多。因为测试人员做接口测试会有更多选择，例如Jmeter、soapUI等。不过，对于开发过程中去调试接口，Postman确实足够的简单方便，而且功能强大</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、Postman最早是作用chrome浏览器插件存在的，所以，你可以到chrome商店搜索下载安装，因为重所周知的原因，所以，大家都会找别人共享的postman插件文件来安装。由于2018年初Chrome停止对Chrome应用程序的支持。</p>
<p>2、Postman提供了独立的安装包，不再依赖于Chrome浏览器了。同时支持MAC、Windows和Linux，推荐你使用这种方式安装。</p>
<pre><code>https://dl.pstmn.io/download/latest/win64
</code></pre>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>DELETE　　　　　　localhost:9200/test
</code></pre>
<h4 id="创建表数据"><a href="#创建表数据" class="headerlink" title="创建表数据"></a>创建表数据</h4><p>localhost:9200/test/_doc/1　　test下id为1的数据提交   __doc是占位符</p>
<h4 id="查询表数据"><a href="#查询表数据" class="headerlink" title="查询表数据"></a>查询表数据</h4><pre><code>GET      localhost:9200/_search?q=content:个人 关键词“个人”查询 单选项查询
</code></pre>
<h4 id="多个索引"><a href="#多个索引" class="headerlink" title="多个索引"></a>多个索引</h4><p>在body中用json格式查询</p>
<pre><code>GET  localhost:9200/_search
body:
{
    "query":{
        "multi_match":{
            "query":"论坛",
            "fields":["title","content"]
        }
    }
}
</code></pre>
<h1 id="Spring整合ElasticeSearch"><a href="#Spring整合ElasticeSearch" class="headerlink" title="Spring整合ElasticeSearch"></a>Spring整合ElasticeSearch</h1><p><a class="link" target="_blank" rel="noopener" href="https://www.freesion.com/article/41621087939/">https://www.freesion.com/article/41621087939/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.12/java-rest-high-getting-started-initialization.html">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.12/java-rest-high-getting-started-initialization.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1795660?from=article.detail.1757034">https://cloud.tencent.com/developer/article/1795660?from=article.detail.1757034<i class="fas fa-external-link-alt"></i></a></p>
<p>引入依赖</p>
<p>   -spring-boot-start-data-elasticsearch</p>
<p>配置Elasticsearch</p>
<p>  -cluster-name、cluster-nodes</p>
<p>Spring Data Elasticsearch</p>
<p>  -ElastcsearchTemple  过时了 不再使用 使用ElasticsearchRestTemplate</p>
<p>  -ElasticsearchRespository search方法也过时了改用ElasticsearchRestTemplate的search()方法</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>ElasticsearchTemplate不建议使用了，改为使用ElasticsearchRestTemplate，ElasticsearchRepository实现复杂查询的方法也不建议使用了。从此我们简单的数据操作可以使用ElasticsearchRepository，而复杂的数据操作只能使用ElasticsearchRestTemplate了</p>
<h2 id="Maven引入依赖"><a href="#Maven引入依赖" class="headerlink" title="Maven引入依赖"></a>Maven引入依赖</h2><pre><code> &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
            &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
            &lt;version&gt;7.12.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
            &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h2 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h2><p>cluster-nodes=</p>
<p>cluster-name=  不再使用</p>
<pre><code>#ElasticsearchProperties
//端口配置
spring.elasticsearch.rest.uris=localhost:9200
spring.data.elasticsearch.repositories.enabled = true
</code></pre>
<pre><code>@Repository
public interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost,Integer&gt; {
}
</code></pre>
<h3 id="接口需要继承ElasticSearchRepository"><a href="#接口需要继承ElasticSearchRepository" class="headerlink" title="接口需要继承ElasticSearchRepository"></a>接口需要继承ElasticSearchRepository</h3><pre><code class="java">@Repository
public interface ItemRepository extends ElasticsearchRepository&lt;Item, Long&gt; {

}
</code></pre>
<h3 id="接口基础用法"><a href="#接口基础用法" class="headerlink" title="接口基础用法"></a>接口基础用法</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><pre><code class="java">@Document(indexName = "discusspost")
public class DiscussPost {
    @Id
    private int id;

    @Field(type = FieldType.Integer)
    private int userId;

    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")
    private  String title;

    @Field(type = FieldType.Text,analyzer = "ik_max_word",searchAnalyzer = "ik_smart")
    private  String content;

    @Field(type = FieldType.Integer)
    private int type;
    @Field(type = FieldType.Integer)
    private int status;
    @Field(type =FieldType.Date)
    private Date createTime;
    @Field(type = FieldType.Integer)
    private int commentCount;
    @Field(type = FieldType.Double)
    private  int score;
}
</code></pre>
<h4 id="ElasticSearchRepository已封装方法"><a href="#ElasticSearchRepository已封装方法" class="headerlink" title="ElasticSearchRepository已封装方法"></a>ElasticSearchRepository已封装方法</h4><pre><code class="java">  @Autowired
    private DiscussPostRepository discussPostRepository;
 @Autowired
    private ElasticsearchRestTemplate elasticsearchRestTemplate;

 public void saveDiscussPost(DiscussPost post){
        discussPostRepository.save(post);
    }
    public void deleteDiscussPost(int id){
        discussPostRepository.deleteById(id);
    }

//保存 或 更新
itemRepository.save(item);
//删除
itemRepository.deleteById(id);

/**
     * 通过id获取信息
     *
     * @param id id
     * @return {@link Item}
     */
public Item esGetInfoById(Long id){
     Optional&lt;Item&gt; item = itemRepository.findById(id); 
     return  item.get();
}
</code></pre>
<p>基于SPRINGBOOT解决ELASTICSEARCH与REDIS的NETTY冲突问题<a class="link" target="_blank" rel="noopener" href="https://www.freesion.com/article/59921236212/">https://www.freesion.com/article/59921236212/<i class="fas fa-external-link-alt"></i></a></p>
<h1 id="项目进阶"><a href="#项目进阶" class="headerlink" title="项目进阶"></a>项目进阶</h1><h2 id="Spring-Scurity"><a href="#Spring-Scurity" class="headerlink" title="Spring Scurity"></a>Spring Scurity</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。提供了完善的<strong>认证机制</strong>和方法级的<strong>授权功能</strong>。是一款非常优秀的权限管理框架。它的核心是一组过滤器链，不同的功能经由不同的过滤器。</p>
<p>一般来说，常见的安全管理技术栈的组合是这样的：</p>
<ul>
<li>SSM + Shiro</li>
<li>Spring Boot/Spring Cloud + Spring Security</li>
</ul>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>  身份的认证和授权</p>
<p>  防止各种攻击</p>
<p>  支持与Servlet API Spring MVC 等web技术集成</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>底层使用Filter（javaEE标准）进行拦截</li>
<li>Filter–&gt;DispatchServlet–&gt;Interceptor–&gt;Controller(后三者属于Spring MVC)</li>
</ul>
<h2 id="任务的执行和调度"><a href="#任务的执行和调度" class="headerlink" title="任务的执行和调度"></a>任务的执行和调度</h2><p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29T4SYDBj70musnkc/root/content"></p>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p><img src="https://api.onedrive.com/v1.0/shares/s!AtrhubmDW-n29T_o0NVF6rCvlfok/root/content"></p>
<h1 id="项目问题解决"><a href="#项目问题解决" class="headerlink" title="项目问题解决"></a>项目问题解决</h1><h2 id="1-AOP没生效"><a href="#1-AOP没生效" class="headerlink" title="1.AOP没生效"></a>1.AOP没生效</h2><h3 id="解决：没有引入aop依赖，不需要引入aspectJ"><a href="#解决：没有引入aop依赖，不需要引入aspectJ" class="headerlink" title="解决：没有引入aop依赖，不需要引入aspectJ"></a>解决：没有引入aop依赖，不需要引入aspectJ</h3><pre><code> &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a class="link" target="_blank" rel="noopener" href="https://www.yimipuzi.com/1156.html">https://www.yimipuzi.com/1156.html<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：论坛项目总结</li>
        <li>Post author：greatBrook</li>
        <li>Create time：2021-06-20 20:57:04</li>
        <li>
            Post link：https://brookdeng.github.io/2021/06/20/论坛项目总结/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/06/22/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E9%98%BF%E9%87%8C%E4%BA%91OSS/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">图片文件压缩并上传至阿里云OSS</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/02/11/%E5%8F%A3%E6%B0%B4%E9%B8%A1/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">口水鸡</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'ED1l4bFn1KPCAPEcbxixj8Px-9Nh9j0Va',
                    appKey: 'IjQK1mCRR6zqIQgEpCGKUEBW',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '尽情吐槽吧~QAQ~',
                    lang: 'zh-tw,en,default'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'greatBrook';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2017</span>&nbsp;-&nbsp;
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">greatBrook</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="nav-text">准备阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8"><span class="nav-text">数据库表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%A1%A8-user"><span class="nav-text">用户表 user</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%84%E8%AE%BA%E8%A1%A8-comment"><span class="nav-text">评论表 comment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%96%E5%AD%90%E8%A1%A8-discuss-post"><span class="nav-text">帖子表 discuss_post</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81%E8%A1%A8-login-ticket"><span class="nav-text">用户登录凭证表 login_ticket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%A1%A8-message"><span class="nav-text">消息表 message</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text">搭建开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Maven"><span class="nav-text">Maven</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-%E6%9E%84%E5%BB%BA-Java-%E9%A1%B9%E7%9B%AE"><span class="nav-text">Maven 构建 Java 项目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC-Inversion-of-Control"><span class="nav-text">IoC Inversion of Control</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">DI(依赖注入)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%92%8CDI%E7%94%B1%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E5%91%A2%EF%BC%9F"><span class="nav-text">IoC和DI由什么关系呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoC%E5%AE%B9%E5%99%A8"><span class="nav-text">IoC容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%80%BC%E6%B3%A8%E5%85%A5"><span class="nav-text">设值注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5"><span class="nav-text">构造注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">两种注入方式的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84Bean"><span class="nav-text">Spring容器中的Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">容器中Bean的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B3%A8%E5%85%A5%E5%90%88%E4%BD%9C%E8%80%85Bean"><span class="nav-text">使用自动装配注入合作者Bean</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BABean%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text">创建Bean的3种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BABean%E5%AE%9E%E4%BE%8B"><span class="nav-text">使用构造器创建Bean实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BABean"><span class="nav-text">使用静态工厂方法创建Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BABean"><span class="nav-text">调用实例工厂方法创建Bean</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E8%B0%83%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8D%E5%90%8C%E6%AD%A5%E7%9A%84Bean"><span class="nav-text">协调作用域不同步的Bean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">两种后处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">Bean后处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">容器后处理器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-amp-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-text">SpringBoot配置文件&amp;运行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%89%8D%E8%A8%80"><span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">2. SpringBoot 配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E9%85%8D%E7%BD%AE-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2.1. 配置 Web 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-properties-%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="nav-text">2.1.1. properties 格式配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-yml-%E6%A0%BC%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="nav-text">2.1.2. yml 格式配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">2.2. 多配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-Properties-%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.2.1. Properties 配置步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%89%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">第一步：编写三个配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-text">第二步：编写配置文件内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE"><span class="nav-text">第三步：运行项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Yml-%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.2.2. Yml 配置步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%89%E4%B8%AA-yml-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">第一步：编写三个 yml 配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%88%86%E5%88%AB%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-text">第二步：分别编写配置信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="nav-text">第三步：启动测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SpringBoot-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-text">3. SpringBoot 运行原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84%E2%80%9D%E9%9B%B6%E9%85%8D%E7%BD%AE%E2%80%9D%E6%94%AF%E6%8C%81"><span class="nav-text">Spring的”零配置”支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2Bean%E7%B1%BB"><span class="nav-text">搜索Bean类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Resource%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96"><span class="nav-text">使用@Resource配置依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PostConstruct%E5%92%8C-PreDestroy%E5%AE%9A%E5%88%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%A1%8C%E4%B8%BA"><span class="nav-text">使用@PostConstruct和@PreDestroy定制生命周期行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring4-0%E5%A2%9E%E5%BC%BA%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%92%8C%E7%B2%BE%E7%A1%AE%E8%A3%85%E9%85%8D"><span class="nav-text">Spring4.0增强的自动装配和精确装配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82ajax"><span class="nav-text">异步请求ajax</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-text">四个步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BAAjax%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%BE%97%E5%88%B0XMLHttpRequest%EF%BC%89"><span class="nav-text">1.创建Ajax对象（得到XMLHttpRequest）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%93%BE%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E6%89%93%E5%BC%80%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-text">2.链接到服务器（打开与服务器的连接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%88%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="nav-text">3.发送请求（发送请求）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%8E%A5%E5%8F%97%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">4.接受返回值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84AOP"><span class="nav-text">Spring的AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP"><span class="nav-text">为什么需要AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AspectJ%E5%AE%9E%E7%8E%B0AOP"><span class="nav-text">使用AspectJ实现AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">AOP的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84AOP%E6%94%AF%E6%8C%81"><span class="nav-text">Spring的AOP支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Repository"><span class="nav-text">@Repository</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-text">Spring的核心机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86Bean"><span class="nav-text">管理Bean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-text">AOP 面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Aspect%EF%BC%88%E5%88%87%E9%9D%A2%EF%BC%89%EF%BC%9A"><span class="nav-text">Aspect（切面）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Joint-point%EF%BC%88%E8%BF%9E%E6%8E%A5%E7%82%B9%EF%BC%89%EF%BC%9A"><span class="nav-text">Joint point（连接点）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pointcut%EF%BC%88%E5%88%87%E7%82%B9%EF%BC%89%EF%BC%9A"><span class="nav-text">Pointcut（切点）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Advice%EF%BC%88%E5%A2%9E%E5%BC%BA%EF%BC%89%EF%BC%9A"><span class="nav-text">Advice（增强）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Target%EF%BC%88%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%EF%BC%89%EF%BC%9A"><span class="nav-text">Target（目标对象）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Weaving%EF%BC%88%E7%BB%87%E5%85%A5%EF%BC%89%EF%BC%9A"><span class="nav-text">Weaving（织入）：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">AOP的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AspectJ"><span class="nav-text">AspectJ</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-AOP"><span class="nav-text">Spring AOP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text">代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">JDK动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">CGLib动态代理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%BC%98%E5%8A%BF"><span class="nav-text">Redis 优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">典型应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#windows%E5%AE%89%E8%A3%85"><span class="nav-text">windows安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-cmd"><span class="nav-text">使用 cmd</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88Redis"><span class="nav-text">Spring整合Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AERedis"><span class="nav-text">配置Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AERedis"><span class="nav-text">访问Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">编程式事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">Redis高级数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HyperLogLog"><span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bitmap%EF%BC%88%E7%BB%9F%E8%AE%A1%E7%94%A8%E6%88%B7%E7%9A%84%E7%AD%BE%E5%88%B0%E6%83%85%E5%86%B5%EF%BC%89"><span class="nav-text">Bitmap（统计用户的签到情况）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-text">实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UV%EF%BC%88Unique-Visitor%EF%BC%89"><span class="nav-text">UV（Unique Visitor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DAU%EF%BC%88Daily-Active-User%EF%BC%89"><span class="nav-text">DAU（Daily Active User）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka"><span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-text">消息系统介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F"><span class="nav-text">点对点消息传递模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%A8%A1%E5%BC%8F"><span class="nav-text">发布-订阅消息传递模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">Kafka的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span class="nav-text">术语解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#broker"><span class="nav-text">broker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topic"><span class="nav-text">Topic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partition"><span class="nav-text">Partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer"><span class="nav-text">Producer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer"><span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer-Group"><span class="nav-text">Consumer Group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader"><span class="nav-text">Leader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Follower"><span class="nav-text">Follower</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-text">配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-text">启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8zookeeper"><span class="nav-text">启动zookeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8kafka-server"><span class="nav-text">启动kafka server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%BB%E9%A2%98"><span class="nav-text">配置主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E9%A2%98"><span class="nav-text">查看主题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%89"><span class="nav-text">创建消息（生产者）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%B6%88%E6%81%AF%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%89"><span class="nav-text">查看消息（消费者）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E6%95%B4%E5%90%88kafka"><span class="nav-text">spring整合kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1"><span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEapplication-properties"><span class="nav-text">配置application.properties</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5"><span class="nav-text">系统消息通知</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BBEvent"><span class="nav-text">实体类Event</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEkafka-eventConsumer-eventProducer"><span class="nav-text">设置kafka eventConsumer eventProducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%9C%A8%E6%B6%88%E6%81%AF%E9%A1%B5%E9%9D%A2%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%B6%88%E6%81%AF"><span class="nav-text">用户在消息页面查看所有消息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ElasticSearch"><span class="nav-text">ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="nav-text">下载安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE-1"><span class="nav-text">配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E7%9A%84%E5%88%86%E8%AF%8D%E6%8F%92%E4%BB%B6"><span class="nav-text">添加中文的分词插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">启动与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Postman%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">Postman安装与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2"><span class="nav-text">查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">创建表数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">查询表数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%B4%A2%E5%BC%95"><span class="nav-text">多个索引</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88ElasticeSearch"><span class="nav-text">Spring整合ElasticeSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-text">注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">Maven引入依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#application-properties"><span class="nav-text">application.properties</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9C%80%E8%A6%81%E7%BB%A7%E6%89%BFElasticSearchRepository"><span class="nav-text">接口需要继承ElasticSearchRepository</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-text">接口基础用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-text">实体类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ElasticSearchRepository%E5%B7%B2%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95"><span class="nav-text">ElasticSearchRepository已封装方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6"><span class="nav-text">项目进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Scurity"><span class="nav-text">Spring Scurity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-text">特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="nav-text">任务的执行和调度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-MVC"><span class="nav-text">Spring MVC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-text">项目问题解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-AOP%E6%B2%A1%E7%94%9F%E6%95%88"><span class="nav-text">1.AOP没生效</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%BC%95%E5%85%A5aop%E4%BE%9D%E8%B5%96%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5aspectJ"><span class="nav-text">解决：没有引入aop依赖，不需要引入aspectJ</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">设计模式</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
